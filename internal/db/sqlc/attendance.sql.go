// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: attendance.sql

package sqlc

import (
	"context"
	"time"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const createAttendance = `-- name: CreateAttendance :one
INSERT INTO attendance (
    student_id,
    subject_id,
    teacher_id,
    semester_id,
    date,
    check_in,
    check_out,
    status,
    method,
    remarks
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9, $10
) RETURNING id, student_id, subject_id, teacher_id, semester_id, date, check_in, check_out, status, method, remarks, created_at, updated_at, deleted_at
`

type CreateAttendanceParams struct {
	StudentID  uuid.UUID          `json:"student_id"`
	SubjectID  uuid.UUID          `json:"subject_id"`
	TeacherID  uuid.UUID          `json:"teacher_id"`
	SemesterID uuid.UUID          `json:"semester_id"`
	Date       pgtype.Date        `json:"date"`
	CheckIn    pgtype.Timestamptz `json:"check_in"`
	CheckOut   pgtype.Timestamptz `json:"check_out"`
	Status     AttendanceStatus   `json:"status"`
	Method     AttendanceMethod   `json:"method"`
	Remarks    pgtype.Text        `json:"remarks"`
}

func (q *Queries) CreateAttendance(ctx context.Context, arg CreateAttendanceParams) (Attendance, error) {
	row := q.db.QueryRow(ctx, createAttendance,
		arg.StudentID,
		arg.SubjectID,
		arg.TeacherID,
		arg.SemesterID,
		arg.Date,
		arg.CheckIn,
		arg.CheckOut,
		arg.Status,
		arg.Method,
		arg.Remarks,
	)
	var i Attendance
	err := row.Scan(
		&i.ID,
		&i.StudentID,
		&i.SubjectID,
		&i.TeacherID,
		&i.SemesterID,
		&i.Date,
		&i.CheckIn,
		&i.CheckOut,
		&i.Status,
		&i.Method,
		&i.Remarks,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const getAttendance = `-- name: GetAttendance :one
SELECT id, student_id, subject_id, teacher_id, semester_id, date, check_in, check_out, status, method, remarks, created_at, updated_at, deleted_at FROM attendance
WHERE id = $1 AND deleted_at IS NULL LIMIT 1
`

func (q *Queries) GetAttendance(ctx context.Context, id uuid.UUID) (Attendance, error) {
	row := q.db.QueryRow(ctx, getAttendance, id)
	var i Attendance
	err := row.Scan(
		&i.ID,
		&i.StudentID,
		&i.SubjectID,
		&i.TeacherID,
		&i.SemesterID,
		&i.Date,
		&i.CheckIn,
		&i.CheckOut,
		&i.Status,
		&i.Method,
		&i.Remarks,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const getAttendanceByStudentSubjectDate = `-- name: GetAttendanceByStudentSubjectDate :one
SELECT id, student_id, subject_id, teacher_id, semester_id, date, check_in, check_out, status, method, remarks, created_at, updated_at, deleted_at FROM attendance
WHERE student_id = $1 AND subject_id = $2 AND date = $3 AND deleted_at IS NULL
LIMIT 1
`

type GetAttendanceByStudentSubjectDateParams struct {
	StudentID uuid.UUID   `json:"student_id"`
	SubjectID uuid.UUID   `json:"subject_id"`
	Date      pgtype.Date `json:"date"`
}

func (q *Queries) GetAttendanceByStudentSubjectDate(ctx context.Context, arg GetAttendanceByStudentSubjectDateParams) (Attendance, error) {
	row := q.db.QueryRow(ctx, getAttendanceByStudentSubjectDate, arg.StudentID, arg.SubjectID, arg.Date)
	var i Attendance
	err := row.Scan(
		&i.ID,
		&i.StudentID,
		&i.SubjectID,
		&i.TeacherID,
		&i.SemesterID,
		&i.Date,
		&i.CheckIn,
		&i.CheckOut,
		&i.Status,
		&i.Method,
		&i.Remarks,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const listAttendanceByStudent = `-- name: ListAttendanceByStudent :many
SELECT id, student_id, subject_id, teacher_id, semester_id, date, check_in, check_out, status, method, remarks, created_at, updated_at, deleted_at FROM attendance
WHERE student_id = $1 AND deleted_at IS NULL
ORDER BY date DESC
`

func (q *Queries) ListAttendanceByStudent(ctx context.Context, studentID uuid.UUID) ([]Attendance, error) {
	rows, err := q.db.Query(ctx, listAttendanceByStudent, studentID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Attendance{}
	for rows.Next() {
		var i Attendance
		if err := rows.Scan(
			&i.ID,
			&i.StudentID,
			&i.SubjectID,
			&i.TeacherID,
			&i.SemesterID,
			&i.Date,
			&i.CheckIn,
			&i.CheckOut,
			&i.Status,
			&i.Method,
			&i.Remarks,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listAttendanceBySubject = `-- name: ListAttendanceBySubject :many
SELECT id, student_id, subject_id, teacher_id, semester_id, date, check_in, check_out, status, method, remarks, created_at, updated_at, deleted_at FROM attendance
WHERE subject_id = $1 AND deleted_at IS NULL
ORDER BY date DESC
`

func (q *Queries) ListAttendanceBySubject(ctx context.Context, subjectID uuid.UUID) ([]Attendance, error) {
	rows, err := q.db.Query(ctx, listAttendanceBySubject, subjectID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Attendance{}
	for rows.Next() {
		var i Attendance
		if err := rows.Scan(
			&i.ID,
			&i.StudentID,
			&i.SubjectID,
			&i.TeacherID,
			&i.SemesterID,
			&i.Date,
			&i.CheckIn,
			&i.CheckOut,
			&i.Status,
			&i.Method,
			&i.Remarks,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listAttendanceForReport = `-- name: ListAttendanceForReport :many
SELECT 
    a.id, a.student_id, a.subject_id, a.teacher_id, a.semester_id, a.date, a.check_in, a.check_out, a.status, a.method, a.remarks, a.created_at, a.updated_at, a.deleted_at, 
    s.first_name, s.last_name, s.roll_no,
    sub.name as subject_name,
    t.first_name as teacher_first_name, t.last_name as teacher_last_name
FROM attendance a
JOIN students s ON a.student_id = s.id
JOIN subjects sub ON a.subject_id = sub.id
JOIN teachers t ON a.teacher_id = t.id
WHERE a.semester_id = $1 
  AND a.date >= $2 
  AND a.date <= $3
  AND a.deleted_at IS NULL
ORDER BY a.date DESC, s.roll_no ASC
`

type ListAttendanceForReportParams struct {
	SemesterID uuid.UUID   `json:"semester_id"`
	Date       pgtype.Date `json:"date"`
	Date_2     pgtype.Date `json:"date_2"`
}

type ListAttendanceForReportRow struct {
	ID               uuid.UUID          `json:"id"`
	StudentID        uuid.UUID          `json:"student_id"`
	SubjectID        uuid.UUID          `json:"subject_id"`
	TeacherID        uuid.UUID          `json:"teacher_id"`
	SemesterID       uuid.UUID          `json:"semester_id"`
	Date             pgtype.Date        `json:"date"`
	CheckIn          pgtype.Timestamptz `json:"check_in"`
	CheckOut         pgtype.Timestamptz `json:"check_out"`
	Status           AttendanceStatus   `json:"status"`
	Method           AttendanceMethod   `json:"method"`
	Remarks          pgtype.Text        `json:"remarks"`
	CreatedAt        time.Time          `json:"created_at"`
	UpdatedAt        time.Time          `json:"updated_at"`
	DeletedAt        pgtype.Timestamptz `json:"deleted_at"`
	FirstName        string             `json:"first_name"`
	LastName         string             `json:"last_name"`
	RollNo           string             `json:"roll_no"`
	SubjectName      string             `json:"subject_name"`
	TeacherFirstName string             `json:"teacher_first_name"`
	TeacherLastName  string             `json:"teacher_last_name"`
}

func (q *Queries) ListAttendanceForReport(ctx context.Context, arg ListAttendanceForReportParams) ([]ListAttendanceForReportRow, error) {
	rows, err := q.db.Query(ctx, listAttendanceForReport, arg.SemesterID, arg.Date, arg.Date_2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListAttendanceForReportRow{}
	for rows.Next() {
		var i ListAttendanceForReportRow
		if err := rows.Scan(
			&i.ID,
			&i.StudentID,
			&i.SubjectID,
			&i.TeacherID,
			&i.SemesterID,
			&i.Date,
			&i.CheckIn,
			&i.CheckOut,
			&i.Status,
			&i.Method,
			&i.Remarks,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.FirstName,
			&i.LastName,
			&i.RollNo,
			&i.SubjectName,
			&i.TeacherFirstName,
			&i.TeacherLastName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const softDeleteAttendance = `-- name: SoftDeleteAttendance :exec
UPDATE attendance
SET deleted_at = NOW()
WHERE id = $1
`

func (q *Queries) SoftDeleteAttendance(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, softDeleteAttendance, id)
	return err
}

const updateAttendance = `-- name: UpdateAttendance :one
UPDATE attendance
SET
    check_in = COALESCE($1, check_in),
    check_out = COALESCE($2, check_out),
    status = COALESCE($3, status),
    remarks = COALESCE($4, remarks),
    updated_at = NOW()
WHERE id = $5 AND deleted_at IS NULL
RETURNING id, student_id, subject_id, teacher_id, semester_id, date, check_in, check_out, status, method, remarks, created_at, updated_at, deleted_at
`

type UpdateAttendanceParams struct {
	CheckIn  pgtype.Timestamptz   `json:"check_in"`
	CheckOut pgtype.Timestamptz   `json:"check_out"`
	Status   NullAttendanceStatus `json:"status"`
	Remarks  pgtype.Text          `json:"remarks"`
	ID       uuid.UUID            `json:"id"`
}

func (q *Queries) UpdateAttendance(ctx context.Context, arg UpdateAttendanceParams) (Attendance, error) {
	row := q.db.QueryRow(ctx, updateAttendance,
		arg.CheckIn,
		arg.CheckOut,
		arg.Status,
		arg.Remarks,
		arg.ID,
	)
	var i Attendance
	err := row.Scan(
		&i.ID,
		&i.StudentID,
		&i.SubjectID,
		&i.TeacherID,
		&i.SemesterID,
		&i.Date,
		&i.CheckIn,
		&i.CheckOut,
		&i.Status,
		&i.Method,
		&i.Remarks,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}
