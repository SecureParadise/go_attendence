// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: core_attendance.sql

package sqlc

import (
	"context"
	"time"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const createAttendanceRecord = `-- name: CreateAttendanceRecord :one
INSERT INTO attendance_records (
    student_id,
    session_id,
    scan_time,
    score,
    status,
    method
) VALUES (
    $1, $2, $3, $4, $5, $6
) RETURNING id, student_id, session_id, scan_time, score, status, method, created_at, updated_at, deleted_at
`

type CreateAttendanceRecordParams struct {
	StudentID uuid.UUID          `json:"student_id"`
	SessionID uuid.UUID          `json:"session_id"`
	ScanTime  pgtype.Timestamptz `json:"scan_time"`
	Score     pgtype.Numeric     `json:"score"`
	Status    AttendanceStatus   `json:"status"`
	Method    AttendanceMethod   `json:"method"`
}

func (q *Queries) CreateAttendanceRecord(ctx context.Context, arg CreateAttendanceRecordParams) (AttendanceRecord, error) {
	row := q.db.QueryRow(ctx, createAttendanceRecord,
		arg.StudentID,
		arg.SessionID,
		arg.ScanTime,
		arg.Score,
		arg.Status,
		arg.Method,
	)
	var i AttendanceRecord
	err := row.Scan(
		&i.ID,
		&i.StudentID,
		&i.SessionID,
		&i.ScanTime,
		&i.Score,
		&i.Status,
		&i.Method,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const createClassSession = `-- name: CreateClassSession :one
INSERT INTO class_sessions (
    subject_id,
    teacher_id,
    semester_id,
    scheduled_start
) VALUES (
    $1, $2, $3, $4
) RETURNING id, subject_id, teacher_id, semester_id, scheduled_start, actual_start, created_at, updated_at, deleted_at
`

type CreateClassSessionParams struct {
	SubjectID      uuid.UUID `json:"subject_id"`
	TeacherID      uuid.UUID `json:"teacher_id"`
	SemesterID     uuid.UUID `json:"semester_id"`
	ScheduledStart time.Time `json:"scheduled_start"`
}

func (q *Queries) CreateClassSession(ctx context.Context, arg CreateClassSessionParams) (ClassSession, error) {
	row := q.db.QueryRow(ctx, createClassSession,
		arg.SubjectID,
		arg.TeacherID,
		arg.SemesterID,
		arg.ScheduledStart,
	)
	var i ClassSession
	err := row.Scan(
		&i.ID,
		&i.SubjectID,
		&i.TeacherID,
		&i.SemesterID,
		&i.ScheduledStart,
		&i.ActualStart,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const createEnrollment = `-- name: CreateEnrollment :one
INSERT INTO enrollments (
    student_id,
    branch_id,
    semester_id,
    academic_year
) VALUES (
    $1, $2, $3, $4
) RETURNING id, student_id, branch_id, semester_id, academic_year, is_active, created_at, updated_at, deleted_at
`

type CreateEnrollmentParams struct {
	StudentID    uuid.UUID `json:"student_id"`
	BranchID     uuid.UUID `json:"branch_id"`
	SemesterID   uuid.UUID `json:"semester_id"`
	AcademicYear string    `json:"academic_year"`
}

func (q *Queries) CreateEnrollment(ctx context.Context, arg CreateEnrollmentParams) (Enrollment, error) {
	row := q.db.QueryRow(ctx, createEnrollment,
		arg.StudentID,
		arg.BranchID,
		arg.SemesterID,
		arg.AcademicYear,
	)
	var i Enrollment
	err := row.Scan(
		&i.ID,
		&i.StudentID,
		&i.BranchID,
		&i.SemesterID,
		&i.AcademicYear,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const getActiveSessionBySubject = `-- name: GetActiveSessionBySubject :one
SELECT id, subject_id, teacher_id, semester_id, scheduled_start, actual_start, created_at, updated_at, deleted_at FROM class_sessions
WHERE subject_id = $1 
  AND actual_start <= NOW() 
  AND actual_start + INTERVAL '90 minutes' >= NOW()
  AND deleted_at IS NULL
LIMIT 1
`

func (q *Queries) GetActiveSessionBySubject(ctx context.Context, subjectID uuid.UUID) (ClassSession, error) {
	row := q.db.QueryRow(ctx, getActiveSessionBySubject, subjectID)
	var i ClassSession
	err := row.Scan(
		&i.ID,
		&i.SubjectID,
		&i.TeacherID,
		&i.SemesterID,
		&i.ScheduledStart,
		&i.ActualStart,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const getActiveSessionByTeacher = `-- name: GetActiveSessionByTeacher :one
SELECT id, subject_id, teacher_id, semester_id, scheduled_start, actual_start, created_at, updated_at, deleted_at FROM class_sessions
WHERE teacher_id = $1 
  AND actual_start <= NOW() 
  AND actual_start + INTERVAL '90 minutes' >= NOW()
  AND deleted_at IS NULL
LIMIT 1
`

func (q *Queries) GetActiveSessionByTeacher(ctx context.Context, teacherID uuid.UUID) (ClassSession, error) {
	row := q.db.QueryRow(ctx, getActiveSessionByTeacher, teacherID)
	var i ClassSession
	err := row.Scan(
		&i.ID,
		&i.SubjectID,
		&i.TeacherID,
		&i.SemesterID,
		&i.ScheduledStart,
		&i.ActualStart,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const getActiveSessionForStudent = `-- name: GetActiveSessionForStudent :one
SELECT cs.id, cs.subject_id, cs.teacher_id, cs.semester_id, cs.scheduled_start, cs.actual_start, cs.created_at, cs.updated_at, cs.deleted_at FROM class_sessions cs
JOIN enrollments e ON cs.semester_id = e.semester_id
WHERE e.student_id = $1 
  AND e.is_active = TRUE
  AND cs.actual_start <= NOW() 
  AND cs.actual_start + INTERVAL '90 minutes' >= NOW()
  AND cs.deleted_at IS NULL
LIMIT 1
`

func (q *Queries) GetActiveSessionForStudent(ctx context.Context, studentID uuid.UUID) (ClassSession, error) {
	row := q.db.QueryRow(ctx, getActiveSessionForStudent, studentID)
	var i ClassSession
	err := row.Scan(
		&i.ID,
		&i.SubjectID,
		&i.TeacherID,
		&i.SemesterID,
		&i.ScheduledStart,
		&i.ActualStart,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const getAttendanceRecordByStudentAndSession = `-- name: GetAttendanceRecordByStudentAndSession :one
SELECT id, student_id, session_id, scan_time, score, status, method, created_at, updated_at, deleted_at FROM attendance_records
WHERE student_id = $1 AND session_id = $2 AND deleted_at IS NULL
LIMIT 1
`

type GetAttendanceRecordByStudentAndSessionParams struct {
	StudentID uuid.UUID `json:"student_id"`
	SessionID uuid.UUID `json:"session_id"`
}

func (q *Queries) GetAttendanceRecordByStudentAndSession(ctx context.Context, arg GetAttendanceRecordByStudentAndSessionParams) (AttendanceRecord, error) {
	row := q.db.QueryRow(ctx, getAttendanceRecordByStudentAndSession, arg.StudentID, arg.SessionID)
	var i AttendanceRecord
	err := row.Scan(
		&i.ID,
		&i.StudentID,
		&i.SessionID,
		&i.ScanTime,
		&i.Score,
		&i.Status,
		&i.Method,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const getClassSession = `-- name: GetClassSession :one
SELECT id, subject_id, teacher_id, semester_id, scheduled_start, actual_start, created_at, updated_at, deleted_at FROM class_sessions
WHERE id = $1 AND deleted_at IS NULL LIMIT 1
`

func (q *Queries) GetClassSession(ctx context.Context, id uuid.UUID) (ClassSession, error) {
	row := q.db.QueryRow(ctx, getClassSession, id)
	var i ClassSession
	err := row.Scan(
		&i.ID,
		&i.SubjectID,
		&i.TeacherID,
		&i.SemesterID,
		&i.ScheduledStart,
		&i.ActualStart,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const getStudentAttendancePercentage = `-- name: GetStudentAttendancePercentage :one
SELECT 
    sub.name as subject_name,
    SUM(ar.score) as total_score,
    COUNT(cs.id) as total_sessions,
    (SUM(ar.score) / COUNT(cs.id)) * 100 as percentage
FROM attendance_records ar
JOIN class_sessions cs ON ar.session_id = cs.id
JOIN subjects sub ON cs.subject_id = sub.id
WHERE ar.student_id = $1 
  AND cs.semester_id = $2
  AND ar.deleted_at IS NULL
GROUP BY sub.name
`

type GetStudentAttendancePercentageParams struct {
	StudentID  uuid.UUID `json:"student_id"`
	SemesterID uuid.UUID `json:"semester_id"`
}

type GetStudentAttendancePercentageRow struct {
	SubjectName   string `json:"subject_name"`
	TotalScore    int64  `json:"total_score"`
	TotalSessions int64  `json:"total_sessions"`
	Percentage    int32  `json:"percentage"`
}

func (q *Queries) GetStudentAttendancePercentage(ctx context.Context, arg GetStudentAttendancePercentageParams) (GetStudentAttendancePercentageRow, error) {
	row := q.db.QueryRow(ctx, getStudentAttendancePercentage, arg.StudentID, arg.SemesterID)
	var i GetStudentAttendancePercentageRow
	err := row.Scan(
		&i.SubjectName,
		&i.TotalScore,
		&i.TotalSessions,
		&i.Percentage,
	)
	return i, err
}

const listAttendanceRecordsBySession = `-- name: ListAttendanceRecordsBySession :many
SELECT 
    ar.id, ar.student_id, ar.session_id, ar.scan_time, ar.score, ar.status, ar.method, ar.created_at, ar.updated_at, ar.deleted_at, 
    s.first_name, s.last_name, s.roll_no
FROM attendance_records ar
JOIN students s ON ar.student_id = s.id
WHERE ar.session_id = $1 AND ar.deleted_at IS NULL
`

type ListAttendanceRecordsBySessionRow struct {
	ID        uuid.UUID          `json:"id"`
	StudentID uuid.UUID          `json:"student_id"`
	SessionID uuid.UUID          `json:"session_id"`
	ScanTime  pgtype.Timestamptz `json:"scan_time"`
	Score     pgtype.Numeric     `json:"score"`
	Status    AttendanceStatus   `json:"status"`
	Method    AttendanceMethod   `json:"method"`
	CreatedAt time.Time          `json:"created_at"`
	UpdatedAt time.Time          `json:"updated_at"`
	DeletedAt pgtype.Timestamptz `json:"deleted_at"`
	FirstName string             `json:"first_name"`
	LastName  string             `json:"last_name"`
	RollNo    string             `json:"roll_no"`
}

func (q *Queries) ListAttendanceRecordsBySession(ctx context.Context, sessionID uuid.UUID) ([]ListAttendanceRecordsBySessionRow, error) {
	rows, err := q.db.Query(ctx, listAttendanceRecordsBySession, sessionID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListAttendanceRecordsBySessionRow{}
	for rows.Next() {
		var i ListAttendanceRecordsBySessionRow
		if err := rows.Scan(
			&i.ID,
			&i.StudentID,
			&i.SessionID,
			&i.ScanTime,
			&i.Score,
			&i.Status,
			&i.Method,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.FirstName,
			&i.LastName,
			&i.RollNo,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateAttendanceRecord = `-- name: UpdateAttendanceRecord :one
UPDATE attendance_records
SET
    scan_time = COALESCE($1, scan_time),
    score = COALESCE($2, score),
    status = COALESCE($3, status),
    method = COALESCE($4, method),
    updated_at = NOW()
WHERE id = $5 AND deleted_at IS NULL
RETURNING id, student_id, session_id, scan_time, score, status, method, created_at, updated_at, deleted_at
`

type UpdateAttendanceRecordParams struct {
	ScanTime pgtype.Timestamptz   `json:"scan_time"`
	Score    pgtype.Numeric       `json:"score"`
	Status   NullAttendanceStatus `json:"status"`
	Method   NullAttendanceMethod `json:"method"`
	ID       uuid.UUID            `json:"id"`
}

func (q *Queries) UpdateAttendanceRecord(ctx context.Context, arg UpdateAttendanceRecordParams) (AttendanceRecord, error) {
	row := q.db.QueryRow(ctx, updateAttendanceRecord,
		arg.ScanTime,
		arg.Score,
		arg.Status,
		arg.Method,
		arg.ID,
	)
	var i AttendanceRecord
	err := row.Scan(
		&i.ID,
		&i.StudentID,
		&i.SessionID,
		&i.ScanTime,
		&i.Score,
		&i.Status,
		&i.Method,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}
